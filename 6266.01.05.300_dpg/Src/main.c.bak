/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
  * All rights reserved.</center></h2>
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "i2c.h"
#include "iwdg.h"
#include "tim.h"
#include "usart.h"
#include "gpio.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include <vector>
#include <algorithm>
#include "push_pop.h"
#include "detector_weather.h"
#include "hcms.h" 
#include "eeprom.h"
#include "nonvol.h"
#include "typedefs_6266.h"
#include <iostream>
#include <stdio.h>
#include <fstream>
#include <numeric>

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
//#define MAX_PROC_COUNT   ((uint16_t)(52UL*240UL))
#define MAX_PROC_COUNT   ((uint16_t)(53UL*240UL))

//#define COUNT_MEASURES   (5280UL)



/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

/* USER CODE BEGIN PV */
static bool sEE_activated = false;


uint8_t flag_profile = 0;

HAL_StatusTypeDef hstd;

class MyEeprom : public Eeprom
{

public:
  MyEeprom()
  {
    if (false == sEE_activated)
    {
      sEE_Init();
      sEE_activated = true;
    }
  }
  virtual bool read(EeAddr addr, void *buf, size_t len)
  {
    bool retval = sEE_Read((unsigned char *)buf, (uint32_t)addr, (uint32_t)len);
    return retval;
  }
// Operations on raw buffers.

  virtual bool write(EeAddr addr, const void *buf, size_t len)
  {
    bool retval = sEE_Write((unsigned char *)buf, static_cast<uint32_t>(addr), static_cast<uint32_t>(len));
    return retval;
  }

#if ERASE_EEPROM

   bool erase( void )
   {
     uint8_t  erase_data [32];
     bool ret_stat   = 0;
     memset( erase_data, 0xff, sizeof(erase_data) );
     for ( int crnt_adr = 0; crnt_adr < 65536; crnt_adr += sizeof(erase_data) )
     {
       ret_stat |= sEE_Write( erase_data, crnt_adr, sizeof(erase_data) );
       if ( ret_stat != true )
         break;
     }
     return (ret_stat == true) ? true : false;
   }
#endif
};

/*
char const          date_ver[] = __DATE__;
#pragma required=date_ver
char const          time_ver[] = __TIME__;
#pragma required=time_ver  */
//char __flash * datetime[]={date_ver,time_ver};

uint8_t             flag_out   = 0;
uint8_t             zro_bt     = 0;


//static int16_t temperature;

struct proc_cntr___
{
  uint8_t proc_count_low;
  uint8_t proc_count_high;
};

struct proc_cntr___ p_cntr     = { (MAX_PROC_COUNT + 1) % 240, (MAX_PROC_COUNT + 1) / 240 };

uint32_t            PL0__      = 0UL,
PG0__      = 0UL,
PLFull     = 0UL,
PGFull     = 0UL;
uint64_t            xxxxPS0    = 0ULL,
xxxxPSFull = 0ULL;
uint32_t xxxxPS0msrs;
uint32_t xxxxPSFullmsrs;

volatile uint8_t    spi_cnt    = 11;
volatile uint16_t   xcoeff     = 1;

volatile bool       dataready  = false;
volatile bool       light_on   = false;
uint32_t            perel_cntr,pwme_cntr;
volatile uint32_t   time__;
volatile bool       flag_test_profile   = true;                   //read profile from file
int16_t profile[COUNT_MEASURES];
//#define DEBUG_TIMING
#ifndef DEBUG_TIMING
volatile bool       timeflag   = false;
#else
volatile bool       timeflag   = true;
#endif

bool aging_LED=0;
bool flag_Kp=0;
bool glass_poll=0;
#include <stdio.h>

double Kp=0;
//  uint32_t rcnt;
//  uint8_t rbts [40];

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

union rslt_                                                                 //SPI_STC_vect
{                                                                           //SPI_STC_vect
  uint8_t bts[4];                                                                //SPI_STC_vect
  uint32_t w;                                                                    //SPI_STC_vect
}
static rslt_un;                                                               //SPI_STC_vect

uint8_t rslt_bt;

//void HAL_SYSTICK_Callback( void )
//{
//  time__++;
//  if ( (time%1000)==0 )
//  {
//    rcnt=0;
//    HAL_SPI_Receive_IT( &hspi1, &rslt_bt, 1 );
//  }
//}

uint32_t get_time(void)
{
  return time__;
}

void HAL_SPI_RxCpltCallback(/*SPI_HandleTypeDef*/void *hspi)
{
//  if (&hspi2 == hspi)
//  {
//    __no_operation();
//  }
  if (NULL == hspi)
  {
//    rcnt++;
//    if ( rcnt < 40 )
//    {
//      rbts[ rcnt ] = rslt_bt;
//      HAL_SPI_Receive_IT( &hspi1, &rslt_bt, 1 );
//    }
//    else
//      return;
  start_case:
    switch (spi_cnt)
    {
//      case 0:
      /*CS2 = 0;*/
//        HAL_GPIO_WritePin( CS2_GPIO_Port, CS2_Pin, GPIO_PIN_RESET );                 // for PG0 & PGFull
      /*SPDR = 0;*/
//        HAL_SPI_Receive_IT( &hspi2, &rslt_bt, 1 );
//        rslt_un.w = 0UL;
//        break;
//      case 1:
//      case 4:
    case 8:
      rslt_un.bts[2] = rslt_bt;
      {
        rslt_bt = 0;
        for (uint8_t mask = 0x80; mask != 0; mask >>= 1)
        {
          HAL_GPIO_WritePin(SPI1_CLK_GPIO_Port, SPI1_CLK_Pin, GPIO_PIN_RESET);
          __no_operation();
          if (HAL_GPIO_ReadPin(SPI1_MISO_GPIO_Port, SPI1_MISO_Pin) == GPIO_PIN_SET)
          {
            rslt_bt |= mask;
          }
          HAL_GPIO_WritePin(SPI1_CLK_GPIO_Port, SPI1_CLK_Pin, GPIO_PIN_SET);
          __no_operation();
        }
        spi_cnt = 9;
        goto start_case;
      }
      /*SPDR = 0;*/
      //HAL_SPI_Receive_IT( &hspi1, &rslt_bt, 1 );   //for bts[1]
//        HAL_SPI_TransmitReceive_IT( &hspi1, ( uint8_t * )&zro_bt, &rslt_bt, 1 );
      break;
//      case 2:
//      case 5:
    case 9:
      rslt_un.bts[1] = rslt_bt;
      /*SPDR = 0;*/
      {
        rslt_bt = 0;
        for (uint8_t mask = 0x80; mask != 0; mask >>= 1)
        {
          HAL_GPIO_WritePin(SPI1_CLK_GPIO_Port, SPI1_CLK_Pin, GPIO_PIN_RESET);
          __no_operation();
          if (HAL_GPIO_ReadPin(SPI1_MISO_GPIO_Port, SPI1_MISO_Pin) == GPIO_PIN_SET)
          {
            rslt_bt |= mask;
          }
          HAL_GPIO_WritePin(SPI1_CLK_GPIO_Port, SPI1_CLK_Pin, GPIO_PIN_SET);
          __no_operation();
        }
        spi_cnt = 10;
        goto start_case;
      }
      //HAL_SPI_Receive_IT( &hspi1, &rslt_bt, 1 ); // for bts[0]
//        HAL_SPI_TransmitReceive_IT( &hspi1, ( uint8_t * )&zro_bt, &rslt_bt, 1 );
      break;
//      case 3:
      /*CS2 = 1;*/
//        HAL_GPIO_WritePin( CS2_GPIO_Port, CS2_Pin, GPIO_PIN_SET );                 // for PG0 & PGFull
      /*CS3 = 0;*/                         //for PL0   & PLFull
//        HAL_GPIO_WritePin( CS3_GPIO_Port, CS3_Pin, GPIO_PIN_RESET );                 // for PG0 & PGFull
//        rslt_un.bts[ 0 ] = rslt_bt & 0xf0;
      /*SPDR = 0;*/
//        HAL_SPI_Receive_IT( &hspi2, &rslt_bt, 1 );
//        if ( p_cntr.proc_count_high == 0 )
//          PG0__ += rslt_un.w;
//        else
//          PGFull += rslt_un.w;
//        rslt_un.w = 0UL;
//        break;
//      case 6:
      /*CS3 = 1;*/
//        HAL_GPIO_WritePin( CS3_GPIO_Port, CS3_Pin, GPIO_PIN_SET );                 // for PG0 & PGFull
//        rslt_un.bts[ 0 ] = rslt_bt & 0xf0;
//        if ( p_cntr.proc_count_high == 0 )
//          PL0__ += rslt_un.w;
//        else
//          PLFull += rslt_un.w;
//        rslt_un.w = 0UL;
//        break;
    case 7:
      /*CS1 = 0;*/
      HAL_GPIO_WritePin(CS1_GPIO_Port, CS1_Pin, GPIO_PIN_RESET);
      /*SPDR = 0;*/
//        HAL_SPI_TransmitReceive_IT( &hspi1, ( uint8_t * )&zro_bt, &rslt_bt, 1 );
//        HAL_SPI_Receive_IT( &hspi1, &rslt_bt, 1 );   // for bts[2]
      {
        rslt_bt = 0;
        for (uint8_t mask = 0x80; mask != 0; mask >>= 1)
        {
          __no_operation();
          HAL_GPIO_WritePin(SPI1_CLK_GPIO_Port, SPI1_CLK_Pin, GPIO_PIN_RESET);
          if (HAL_GPIO_ReadPin(SPI1_MISO_GPIO_Port, SPI1_MISO_Pin) == GPIO_PIN_SET)
          {
            rslt_bt |= mask;
          }
          HAL_GPIO_WritePin(SPI1_CLK_GPIO_Port, SPI1_CLK_Pin, GPIO_PIN_SET);
          __no_operation();
        }
        spi_cnt = 8;
      }
      rslt_un.w = 0UL;
      goto start_case;
      break;
    case 10:
      {
        /*CS1 = 1;*/
        HAL_GPIO_WritePin(CS1_GPIO_Port, CS1_Pin, GPIO_PIN_SET);
        rslt_un.bts[0] = rslt_bt; //& 0xf0; // low four bits of third byte ADC ignored

        if (xxxxPSFullmsrs<10560)
        {
          xxxxPSFull += (uint64_t)((rslt_un.w & 0xffff0ul) >> 4);
          xxxxPSFullmsrs++;
        }
        if ((p_cntr.proc_count_high >= 8) &&
            (p_cntr.proc_count_high <= 51) &&
            (xxxxPSFullmsrs < 10560))
           profile[(p_cntr.proc_count_high - 8) * 240 + p_cntr.proc_count_low] = (uint16_t)((rslt_un.w & 0xffff0) >> 4);


        if (p_cntr.proc_count_high == 52)
        {
          xxxxPS0 += (uint64_t)((rslt_un.w & 0xffff0) >> 4);
          xxxxPS0msrs++;
          break;
        }
        else spi_cnt = 11;
        break;
      }
    case 11:
      return;
    }
    spi_cnt++;

  }
}

volatile uint32_t ccr2 = 0; //3000;

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
  if (htim == &htim1)
  {
//    perel_cntr++;
    if (light_on)
    {
      /*CA = 0;*/     //light on -> 0 // above zones0 & 1
      HAL_GPIO_WritePin(CA_GPIO_Port, CA_Pin, GPIO_PIN_RESET);
    }
    static uint16_t x_proc_count;
    x_proc_count = ((((uint16_t)p_cntr.proc_count_high) * 240) + ((uint16_t)p_cntr.proc_count_low));
    if (
//      proc_count<MAX_PROC_COUNT
//     (p_cntr.proc_count_high < (MAX_PROC_COUNT/240))||
//     (p_cntr.proc_count_low < (MAX_PROC_COUNT % 240))
//(((( uint16_t )p_cntr.proc_count_high) * 240) + (( uint16_t )p_cntr.proc_count_low)) < MAX_PROC_COUNT
        x_proc_count <   MAX_PROC_COUNT
       )
    {
      ccr2 = htim1.Instance->CCR2 = 300;
      HAL_TIM_PWM_Start_IT(&htim1, TIM_CHANNEL_2);
      switch (p_cntr.proc_count_high)
      {
      case 0x2:
      case 0x3:
//      k_img=4;// x4     k3=1 k2=0 k1=0
        /*K3 = 1;*/
        HAL_GPIO_WritePin(K3_GPIO_Port, K3_Pin, GPIO_PIN_SET);
        /*K2 = 0;*/
        HAL_GPIO_WritePin(K2_GPIO_Port, K2_Pin, GPIO_PIN_RESET);
        /*K1 = 0;*/
        HAL_GPIO_WritePin(K1_GPIO_Port, K1_Pin, GPIO_PIN_RESET);
        xcoeff = 4;
        break;
      case 0x4:
      case 0x5:
//      k_img=5;// x40    k3=1 k2=0 k1=1
        /*K3 = 1;*/
        HAL_GPIO_WritePin(K3_GPIO_Port, K3_Pin, GPIO_PIN_SET);
        /*K2 = 0;*/
        HAL_GPIO_WritePin(K2_GPIO_Port, K2_Pin, GPIO_PIN_RESET);
        /*K1 = 1; */
        HAL_GPIO_WritePin(K1_GPIO_Port, K1_Pin, GPIO_PIN_SET);
        xcoeff = 40;
        break;
      case 0x6:
      case 0x7:
//      k_img=6;// x400   k3=1 k2=1 k1=0
        /*K3 = 1;*/
        HAL_GPIO_WritePin(K3_GPIO_Port, K3_Pin, GPIO_PIN_SET);
        /*K2 = 1;*/
        HAL_GPIO_WritePin(K2_GPIO_Port, K2_Pin, GPIO_PIN_SET);
        /*K1 = 0;*/
        HAL_GPIO_WritePin(K1_GPIO_Port, K1_Pin, GPIO_PIN_RESET);
        xcoeff = 400;
        break;
      }
    }
    time__++;
    static uint32_t ytime;
    ytime = time__ % 15000;
    if (ytime == 0x0)
    {
      __no_operation();

        timeflag = true;

    }
//
//  if (
//     (dataready==false)&&
//     (timeflag==false)&&
////     (proc_count==(MAX_PROC_COUNT+1))&&
//     (
//     (p_cntr.proc_count_high==((MAX_PROC_COUNT+1)/240))&&
//     (p_cntr.proc_count_low==((MAX_PROC_COUNT+1) % 240))
//     )&&
//     (obf.obd.bs.curr_state==OBUF_STATE_FREE)
//     )
//    timeflag=true;
#define OCF1A__ TIFR_Bit4
    ////
    ////*TIFR_*/OCF1A__ = 1; //preventive clear interrupt flag on
    ///ocr1a compare
  }
}

//#define TEN_PERCENT_LIMIT (((65536UL/10UL)*240UL)<<4)
#define TEN_PERCENT_LIMIT (65536ul/10ul)

//int c1600cntr=0,c300ex1600=0;
#ifdef DWTTM
struct dwttm__
{
  uint32_t cycnt;
  uint32_t evnt;
}evnts[64];
int evidx = 0;
#endif
void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
{
  if (htim == &htim1)
  {
    /*switch ( OCR1B )*/
    switch (/*htim1.Instance->CCR2*/ccr2)
    {
    case 300: //150 us
      if (
          (p_cntr.proc_count_high < 2) &&
          (p_cntr.proc_count_low < 240)
         )
      {
        //  spi_cnt = 0;
//      SPDR=0;    // start SPI_SEQUENCE from pos0 to pos6
        rslt_un.w = 0;
        //uint32_t w;
        //uint8_t  i;
        /*CLK2 = CS1 = CS2 = CS3 = 1;*/
//          HAL_GPIO_WritePin( CLK2_GPIO_Port, CLK2_Pin, GPIO_PIN_SET );
        HAL_GPIO_WritePin(CS1_GPIO_Port, CS1_Pin, GPIO_PIN_SET);
        HAL_GPIO_WritePin(CS2_GPIO_Port, CS2_Pin, GPIO_PIN_SET);
        HAL_GPIO_WritePin(CS3_GPIO_Port, CS3_Pin, GPIO_PIN_SET);
        //w = 0ul;
        //__delay_cycles( 6 );
        __no_operation();
        __no_operation();
        __no_operation();
        __no_operation();
        __no_operation();
        __no_operation();
        /*CS2 = 0;*/
        HAL_GPIO_WritePin(CS2_GPIO_Port, CS2_Pin, GPIO_PIN_RESET);
        for (int i = 0; i < 24; i++)
        {
          rslt_un.w <<= 1;
          /*if ( DATA2 != 0 )*/
          if (HAL_GPIO_ReadPin(DATA2CPU_GPIO_Port, DATA2CPU_Pin) != GPIO_PIN_RESET)
          {
            rslt_un.w |= 1ul;        //------------------------------------
          }
          /*CLK2 = 0;*/
          HAL_GPIO_WritePin(CLK2_GPIO_Port, CLK2_Pin, GPIO_PIN_RESET);
        __no_operation();
        __no_operation();
        __no_operation();
        __no_operation();
        __no_operation();
        __no_operation();
//          __delay_cycles(6);
          /*CLK2 = 1;*/
          HAL_GPIO_WritePin(CLK2_GPIO_Port, CLK2_Pin, GPIO_PIN_SET);
        }
        /*CS2 = 1;*/
//        HAL_SPI_Receive(&hspi2, rslt_un.bts, 3, 1)
        HAL_GPIO_WritePin(CS2_GPIO_Port, CS2_Pin, GPIO_PIN_SET);
//        rslt_bt = rslt_un.bts[0];
//        rslt_un.bts[0] = rslt_un.bts[2];
//        rslt_un.bts[2] = rslt_bt;
        if (p_cntr.proc_count_high == 0)
          PG0__ += (rslt_un.w & 0xffff0) >> 4;
        else
          PGFull += (rslt_un.w & 0xffff0) >> 4;
        rslt_un.w = 0ul;
        //__delay_cycles( 6 );
        __no_operation();
        __no_operation();
        __no_operation();
        __no_operation();
        __no_operation();
        __no_operation();
        /*CS3 = 0;*/
        rslt_un.w = 0;
        HAL_GPIO_WritePin(CS3_GPIO_Port, CS3_Pin, GPIO_PIN_RESET);
        //HAL_SPI_Receive(&hspi2, rslt_un.bts, 3, 1);
//        HAL_GPIO_WritePin(CS2_GPIO_Port, CS3_Pin, GPIO_PIN_SET);
//        rslt_bt = rslt_un.bts[0];
//        rslt_un.bts[0] = rslt_un.bts[2];
//        rslt_un.bts[2] = rslt_bt;
        for (int i = 0; i < 24; i++)
        {
          rslt_un.w <<= 1;
          /*if ( DATA2 != 0 )*/
          if (HAL_GPIO_ReadPin(DATA2CPU_GPIO_Port, DATA2CPU_Pin) != GPIO_PIN_RESET)
          {
            rslt_un.w |= 1ul;        //--------------------------------------------
          }
          /*CLK2 = 0;*/
          HAL_GPIO_WritePin(CLK2_GPIO_Port, CLK2_Pin, GPIO_PIN_RESET);
        __no_operation();
        __no_operation();
        __no_operation();
        __no_operation();
        __no_operation();
        __no_operation();
//          __delay_cycles(6);
          /*CLK2 = 1;*/
          HAL_GPIO_WritePin(CLK2_GPIO_Port, CLK2_Pin, GPIO_PIN_SET);
        }
        /*CS3 = 1;*/
        HAL_GPIO_WritePin(CS3_GPIO_Port, CS3_Pin, GPIO_PIN_SET);
        if (p_cntr.proc_count_high == 0)
          PL0__ += (rslt_un.w & 0xffff0) >> 4;
        else
          PLFull += (rslt_un.w & 0xffff0) >> 4;
        /*OCR1B = 1600;*/ //for advance proc_count
        ccr2 = htim1.Instance->CCR2 = 1600;

        __no_operation();
        break;

      }
      /*OCR1B = 600;*/
      ccr2 = htim1.Instance->CCR2 = 600;
      __no_operation();
      break;
    case  600: //300 uS
      //PD = 1; // PD_ON
      HAL_GPIO_WritePin(PD_GPIO_Port, PD_Pin, GPIO_PIN_SET);
      /*OCR1B = 1000;*/ //next event on 0,5ms
      ccr2 = htim1.Instance->CCR2 = 1000;
      __no_operation();
      break;
    case 1000: //500 uS
               //CA = 1;                 //laser off
     HAL_GPIO_WritePin(CA_GPIO_Port, CA_Pin, GPIO_PIN_SET);
      /*OCR1B = 1400;*/
      ccr2 = htim1.Instance->CCR2 = 1400;
      __no_operation();
      break;
    case 1400: //700 uS
      if (
          (
           (p_cntr.proc_count_high == 3) ||
           (p_cntr.proc_count_high == 5) ||
           (
            (p_cntr.proc_count_high >= 7) &&
            (p_cntr.proc_count_high <= 53)
           )
          ) &&
          (p_cntr.proc_count_low < 240)
         )
      {
        spi_cnt = 7;
        //<><><><><><>SPDR = 0;    // start SPI_SEQUENCE from pos7 to pos10
        {
          rslt_bt = 0;
//          for (uint8_t mask = 0x80; mask != 0; mask >>= 1)
//          {
//            HAL_GPIO_WritePin(SPI1_CLK_GPIO_Port, SPI1_CLK_Pin, GPIO_PIN_RESET);
//            if (HAL_GPIO_ReadPin(SPI1_MISO_GPIO_Port, SPI1_MISO_Pin) == GPIO_PIN_SET)
//            {
//              rslt_bt |= mask;
//            }
//            HAL_GPIO_WritePin(SPI1_CLK_GPIO_Port, SPI1_CLK_Pin, GPIO_PIN_SET);
//          }
          HAL_SPI_RxCpltCallback(NULL);
        }
        // HAL_SPI_Receive_IT( &hspi1, &rslt_bt, 1 );
        //HAL_SPI_TransmitReceive_IT( &hspi1, ( uint8_t * )&zro_bt, &rslt_bt, 1 );


      }
      /*OCR1B = 1600;*/
      ccr2 = htim1.Instance->CCR2 = 1600;
      __no_operation();
      break;
    case 1600: //800 uS
               //PD = 0; //PORTA=k_img;//PD_OFF
      //HAL_GPIO_WritePin(CA_GPIO_Port, CA_Pin, GPIO_PIN_SET);
      HAL_GPIO_WritePin(PD_GPIO_Port, PD_Pin, GPIO_PIN_RESET);
//      proc_count++;
      {
        p_cntr.proc_count_low++;
        if (p_cntr.proc_count_low == 240)
        {
          p_cntr.proc_count_low = 0;
          p_cntr.proc_count_high++;
        }
      }
      if (p_cntr.proc_count_high == 7) __no_operation();
      if (p_cntr.proc_count_low == 0)
      { // goto apply
        if (
            (p_cntr.proc_count_high == 4) ||
            (p_cntr.proc_count_high == 6)
           )
        {
          if ((xxxxPSFull / /*240ul*/xxxxPSFullmsrs) >= TEN_PERCENT_LIMIT)
          {
            //proc_count=0x800;
            p_cntr.proc_count_low = 0;
            p_cntr.proc_count_high = 8;
          }
          xxxxPS0 = xxxxPSFull = xxxxPS0msrs = xxxxPSFullmsrs= 0ULL;
        }
      }
//      if (proc_count==(MAX_PROC_COUNT))
      if (
          (p_cntr.proc_count_low == (MAX_PROC_COUNT % 240)) &&
          (p_cntr.proc_count_high == (MAX_PROC_COUNT / 240))
         )
      {
//        proc_count++;
        p_cntr.proc_count_low++;
        /*TIMSK_*/ //<><><><><><><>    OCIE1B__ = 0;
                   //HAL_TIM_PWM_Stop_IT( &htim1, TIM_CHANNEL_2 );
        light_on = false;
        dataready = true;
      }
      else
      {
        if (
            (
             (p_cntr.proc_count_high >= 1) &&
             (p_cntr.proc_count_high <= 7)
            )
            ||
            (
             (p_cntr.proc_count_high < 52) &&
             (p_cntr.proc_count_high >= 8) //&&
                                           //((p_cntr.proc_count_high & 1) == 0)
            )
           )
        {
          light_on = true;//reset
          if(p_cntr.proc_count_high>=53)
            __no_operation();
        }
        else
        {
          light_on = false;//set
        }
      }
      /*OCR1B = 3000;*/ //never exist
      ccr2 = htim1.Instance->CCR2 = 0; //3000;
      __no_operation();
      break;
    default:
      break;
    }
//  DDRA=oldddra;
//  PORTA=oldporta;
#define OCF1B__ TIFR_Bit3
    /*TIFR_*/ //<><><><><><><><><> OCF1B__ = 1; //preventive clear interrupt flag on ocr1b compare
  }
}


#define MAX_STK_LVL (8)

double  PLstack[MAX_STK_LVL];

uint8_t stkidxPL   = 0;
uint8_t stk_lvlPL  = 0;  

double  PSstack[MAX_STK_LVL];

uint8_t stkidxPS   = 0;
uint8_t stk_lvlPS  = 0;

double  MORstack[MAX_STK_LVL];

uint8_t stkidxMOR  = 0;
uint8_t stk_lvlMOR = 0;



void uint32_t_to_segleds_with_dspoints(uint32_t val)
{
  uint8_t tmpbuf[7];
  hcms_clear();
  tmpbuf[0] = val / 10000ul == 0ul ? ' ' : (val / 10000 + '0');
  tmpbuf[1] = ((val / 1000ul) % 10ul) + '0';
  tmpbuf[2] = '.';
  tmpbuf[3] = ((val / 100ul) % 10ul) + '0';
  tmpbuf[4] = ((val / 10ul) % 10ul) + '0';
  tmpbuf[5] = (val % 10ul) + '0';
  tmpbuf[6] = 0;
  hcms_putchars((char *)tmpbuf, 6);
  hcms_putbuf();
}

int16_t termo_val = 250;
uint8_t xbuf[256];

#include <math.h>

void smooth(uint16_t *input, float *output, int n, int window)
{
  int   i,
      j,
      z,
      k1,
      k2,
      hw;
  float tmp;
  if (fmod(window, 2.0f) == 0.0f) window++;
  hw = (window - 1) / 2;

  output[0] = (float)input[0];

  for (i = 1; i < n; i++)
  {
    tmp = 0.0f;
    if (i < hw)
    {
      k1 = 0;
      k2 = 2 * i;
      z = k2 + 1;
    }
    else
    {
      if ((i + hw) > (n - 1))
      {
        k1 = i - n + i + 1;
        k2 = n - 1;
        z = k2 - k1 + 1;
      }
      else
      {
        k1 = i - hw;
        k2 = i + hw;
        z = window;
      }
    }
    for (j = k1; j <= k2;
         j++)
    {
      tmp = tmp + (float)input[j];
    }
    output[i] = tmp / z;
  }
}




double get_double_from_pkt(uint8_t *datebts)
{
  double retval = 0.0;

  sscanf((char const *)&datebts[1],"%10lg",&retval);
  return retval;
}

void putpkt(uint8_t state, uint8_t mode, double val)
{
  init_serv_obf(state, mode);
  sprintf((char *)&obuf[4], "%010.0f", val);
  uint16_t chk = 0;
  for (int i = 1; i < 14; i++)
  {
    chk += (uint16_t)obuf[i];
  }
  chk = (chk & 0xff) + ((chk >> 8) & 0xff);
  obuf[14] = ((chk >> 4) & 0xf) + 0x40;
  obuf[15] = (chk & 0xf) + 0x40;
  HAL_UART_Transmit(&huart4, obuf, 17, 150);
  HAL_Delay(25);
}



void putpkt(uint32_t send_val, uint16_t pogoda = 0xffff)
{
  uint8_t  i;
  uint16_t chk = 0;
  init_obf();
//  while ( oidx < (sizeof(obuf) + 1) )
//    continue;
  obuf[4] = ((send_val / 10000ul) % 10ul) + '0';
  obuf[5] = ((send_val / 1000ul) % 10ul) + '0';
  obuf[6] = ((send_val / 100ul) % 10ul) + '0';
  obuf[7] = ((send_val / 10ul) % 10ul) + '0';
  obuf[8] = (send_val % 10ul) + '0';
  if (pogoda != 0xffff)
  {
    //obuf[9] = (pogoda >> 8) & 0xff;
    //obuf[10] = pogoda & 0xff;
    obuf[9] = ((pogoda >> 4) & 0xf) + 0x30;
    obuf[10] = (pogoda & 0xf) + 0x30;
  }
  for (i = 1; i < 14; i++)
  {
    chk += (uint16_t)obuf[i];
  }
  chk = (chk & 0xff) + ((chk >> 8) & 0xff);
  obuf[14] = ((chk >> 4) & 0xf) + 0x40;
  obuf[15] = (chk & 0xf) + 0x40;
  oidx = 0;
  //UCSR1B_UDRIE1__ = 1;
  HAL_UART_Transmit(&huart4, obuf, 17, 150);
  HAL_Delay(25);
}


bool getpkt(void)
{
  uint8_t chkhi;
  uint8_t chklo;
  uint16_t chk = 0;

  /*M0=0;*/
  HAL_GPIO_WritePin(M0_GPIO_Port, M0_Pin, GPIO_PIN_RESET);
  /*M1=1;*/
  HAL_GPIO_WritePin(M1_GPIO_Port, M1_Pin, GPIO_PIN_SET);
  /*T485_EN=0;//rx */
  HAL_GPIO_WritePin(RDE_GPIO_Port, RDE_Pin, GPIO_PIN_RESET);
  hstd = HAL_UART_Receive(&huart4, ibuf, 17, 1000); 
  if(hstd==HAL_OK)
  {
  if (huart4.RxXferCount <= 4) //if (ibuf_rdy)
                               //if(HAL_OK==hstd)
  {
    struct istruct__ *istr_ptr = (struct istruct__ *)ibuf;
    //checking crc
    for (int i = 1; i < 14; i++)
    {
      chk += (uint16_t)((uint8_t *)istr_ptr)[i];
    }
    chk = (chk & 0xff) + ((chk >> 8) & 0xff);
    chkhi = ((chk >> 4) & 0xf) + 0x40;
    chklo = (chk & 0xf) + 0x40;
/*
15-1=14 XX  Контрольная сумма    Старший разряд
16-1=15 XX  Контрольная сумма   Младший разряд
17-1=16 0D  Стоп    «Возврат каретки»
*/

  }
  //M0=1;M1=0;T485_EN=1;//tx
  HAL_GPIO_WritePin(M0_GPIO_Port, M0_Pin, GPIO_PIN_SET);
  /*M1=0;*/
  HAL_GPIO_WritePin(M1_GPIO_Port, M1_Pin, GPIO_PIN_RESET);
  /*T485_EN=1;//tx */
  HAL_GPIO_WritePin(RDE_GPIO_Port, RDE_Pin, GPIO_PIN_SET);
  if ((ibuf[14] == chkhi) && (ibuf[15] == chklo))
    return true;
  }
    return false;
}
int count_retry=0;
uint8_t report[4]={0x01,0x00,0x06,0x0D};


void put_profile(uint8_t index, uint16_t  size_profile)
{
  static uint8_t buf_profile[265];
  uint16_t  i=0;
  uint16_t  j=5;
  uint16_t  size_package=0x105;//???
  uint16_t chk = 0;
  uint16_t  buf_index=index*128; //???

  buf_profile[0] = 0x01;
  buf_profile[1] = ((size_profile-1)/128) - ((size_profile % 128 == 0)? (1) : (0));//0x50;

  buf_profile[2] = index;
  buf_profile[3] = 400/xcoeff;
  buf_profile[4] = 0x02;
  for ( j = 5; j < size_package;j+=2,buf_index+=1)
  {
    if ( buf_index <= size_profile )
    {
      buf_profile[j+1] = profile[ buf_index ];
      buf_profile[ j ] = profile[ buf_index ] >> 8 ;
    }
    else
      break;
  }

  buf_profile[ j ] = 0x03;

  for (i = 1; i < j; i++)
  {
    chk += (uint16_t)buf_profile[i];
  }
  chk = (chk & 0xff) + ((chk >> 8) & 0xff);
  buf_profile[ j+1 ] = ((chk >> 4) & 0xf) + 0x40;
  buf_profile[ j+2 ] = (chk & 0xf) + 0x40;
  buf_profile[ j+3 ] = 0xd;
  oidx = 0;
  HAL_UART_Transmit( &huart4, buf_profile, j+4,110);   
 // HAL_Delay(20);           //rjvtyn
}

void mode_profile()
{
  int size_profile=0;
  for ( int i = COUNT_MEASURES-1;  i >=0 ;i--)
  {
    if( profile[i]!=0x00)
    {
      size_profile=i;
      break;
    }
  }
  uint8_t index = 0;
  for ( int i = size_profile;  i > 0;)
  {
    put_profile( index, size_profile);

    HAL_GPIO_WritePin( M0_GPIO_Port, M0_Pin, GPIO_PIN_RESET );
    HAL_GPIO_WritePin( M1_GPIO_Port, M1_Pin, GPIO_PIN_SET );
    HAL_GPIO_WritePin( RDE_GPIO_Port, RDE_Pin, GPIO_PIN_RESET );

    HAL_UART_Receive( &huart4, report, 4,70);  
  /*  if ( report[ 2 ] == 0x06 )
    {
       count_retry = 0;
       i -= 128;
       index += 1;
       HAL_Delay(1);   
    }         */
    if ( report[ 2 ] == 0x05 )
    {
       if ( count_retry >= 2 )
       {
         count_retry=0;
         break;
       }
       count_retry += 1;
      
    }
    else 
    {
       count_retry = 0;
       i -= 128;
       index += 1;
       HAL_Delay(1);
    }
    HAL_Delay(70);  

    HAL_GPIO_WritePin( M0_GPIO_Port, M0_Pin, GPIO_PIN_SET );
    HAL_GPIO_WritePin( M1_GPIO_Port, M1_Pin, GPIO_PIN_RESET );
    HAL_GPIO_WritePin( RDE_GPIO_Port, RDE_Pin, GPIO_PIN_SET );
   }
}


void test_profile( FILE *file_profile, int  count_profile, int sym)            ////////test
{
  uint32_t numb1=0x01;
  uint32_t numb2=0x01;
  uint32_t numb3=0x01;
  uint32_t numb4=0x01;
int time=1;

  char buffer1[1000];
  char* end;

  int count=0;
  for(int i=0; i<10560;i++)
     profile[i] = 0;

  int j=0;
  while (sym!=EOF)
  {
      fgets(buffer1,815, file_profile);
      if(buffer1[15-time]=='0' && buffer1[16-time]=='0' && count>0)
      {
          fseek (file_profile,-900,SEEK_CUR);
           fgets(buffer1,100, file_profile);
           break;
      }
      else
    {
    count++;

    int index=24-time;
    while(1)
    {

      numb1= strtol(&buffer1[index],&end,16);
      index+=3;
      numb2=strtol(&buffer1[index],&end,16);
      index+=3;

       if(numb1==0x03)
       {
         numb4 = strtol(&buffer1[index+3],&end,16);
         if(numb4==0x0D)
         {
           index+=6;
           break;
         }
       }
       profile[j]=(numb1<<8)+numb2;
       j++;
    }
     while(buffer1[index]!=0x0A)
     {
       if((buffer1[index])=='\0')
       {
          sym = fgetc (file_profile);
          break;
       }
       index+=1;
     }
  }
  }

  if(sym == EOF)
  {
    rewind(file_profile);
    count_profile=0;
    sym=0;
  }
  else
    count_profile++;
}////end test


uint32_t PL;                   //  output values
uint32_t PG;                   //
double   PS   = 0.0, PS0x = 0.0;
uint32_t PL0x = 0, PG0x = 0;    //
double PLmomentary = 0.0;
uint8_t pogoda = 0x00;

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* USER CODE BEGIN 1 */
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_I2C1_Init();
  MX_I2C2_Init();
  MX_UART4_Init();
  MX_TIM1_Init();
  MX_IWDG_Init();
  /* USER CODE BEGIN 2 */
//  do
//  {
//    for(int i=0 ;i<16;i++)
//      xbuf[i]=i;
//    sEE_Write(xbuf,0,16);
//  sEE_Read(xbuf,0,256);
//  }while(1);
  MyEeprom        eeprom;       // Eeprom-derived device driver
#if ERASE_EEPROM
  eeprom.erase();
#endif
  NvStore         nvStore(eeprom, EeAddr(0), EeAddr(65535));            // storage layout manager
//Nv < Commands > commands( GET_STARTP_PROFILE, nvStore, "commands" );

//uint16_t MORmsb;
  Nv<mORmsb>   MORmsb(50000, nvStore, "MORmsb");

  Nv<pSmsb>    PSmsb(3.5, nvStore, "PSmsb");
  Nv<mORlsb>   MORlsb(7500, nvStore, "MORlsb");
  Nv<pSlsb>    PSlsb(30.0, nvStore, "PSlsb");
  Nv<cORR_val> CORR_val(-3.14159265358979323, nvStore, "CORR_val");
  Nv<sIGMA>    SIGMA(-3.14159265358979323, nvStore, "SIGMA");

  Nv<Drizzlethreshold>       drizzlethreshold(55555, nvStore, "drizzlethreshold");
  Nv<Precipitationthreshold> precipitationthreshold(55555, nvStore, "precipitationthreshold");

/*  Nv<Clearthreshold> clearthreshold(150, nvStore, "clearthreshold");      //ясно
  Nv<Noisethreshold> noisethreshold(75, nvStore, "noisethreshold");       //шум
  Nv<Hazethreshold> hazethreshold(50, nvStore, "hazethreshold");          //дымка
  Nv<Fogthreshold> fogthreshold  (400, nvStore, "fogthreshold");          //туман
  Nv<Diffdrizzlethreshold> diffdrizzlethreshold(125, nvStore, "diffdrizzlethreshold");       //морозь
  Nv<Diffprecipitationthreshold > diffprecipitationthreshold  (300, nvStore, "diffprecipitationthreshold");    //осадки
   */
  Nv<E_maxminamplitude> e_maxminamplitude(0, nvStore, "e_maxminamplitude");
  
  uint16_t noisethreshold=75;
  
  uint16_t diffdrizzlethreshold=125;
  uint16_t diffprecipitationthreshold=300;
  
  hcms_init();
  hcms_clear();
  hcms_putchars((char *)"strt", 5);
  hcms_putbuf();
  init_obf();
  termo_init();
  hcms_clear();
  HAL_TIM_Base_Start_IT(&htim1);
  uint32_t tmeas_started_time = 0UL;


  //test value
  //FILE *file_profile =  fopen("C:\\Profile.txt", "r");
  int sym=0x0A;
  int count_profile=0;

  //test value

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    HAL_IWDG_Refresh(&hiwdg);
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
    //uint8_t pogoda = 0x00;
    double PSmomentary = 0.0,PLmomentary = 0.0, MORmomentary = 0.0, MORstacked = 0.0, PLref=0;
    double MORmomentary_koeff = 0.0;
    if (((get_time() - tmeas_started_time) >= 1000UL) && ( //proc_count==(MAX_PROC_COUNT+1)
                                                           (p_cntr.proc_count_low == ((MAX_PROC_COUNT + 1) % 240)) &&
                                                           (p_cntr.proc_count_high == ((MAX_PROC_COUNT + 1) / 240))))
    {
      termo_val = get_termoval();
      /*T=1;*/
      HAL_GPIO_WritePin(T_GPIO_Port, T_Pin, GPIO_PIN_SET);
      tmeas_started_time = get_time();
    }
    if (timeflag)
    {
      //printf("timer");
      PL0__ = PG0__ = xxxxPS0 = PLFull = PGFull = xxxxPSFull = xxxxPS0msrs = xxxxPSFullmsrs= 0ULL;
      timeflag = false;
//      memset(segleds,0,sizeof(segleds));
      hcms_clear();
//      proc_count=0;   //start of business
      p_cntr.proc_count_low = p_cntr.proc_count_high = 0;
    }
    if ( dataready ) // check for ready of accumulated data
    {
      HAL_GPIO_WritePin( T_GPIO_Port, T_Pin, GPIO_PIN_RESET );
      if ( flag_profile == 1 )
      {
       // test_profile(file_profile, count_profile, sym);
        mode_profile();
      }
      if(flag_profile==0)
     { 
       PL = ((PLFull/*>>4*/) / 240UL);   //  make output values from accumulated data
       PL0x = ((PL0__/*>>4*/) / 240UL);
       if ( PL < PL0x )             //check if is negative value
         PL = PL0x;                //correct it
       PL = PL - PL0x;
       push(stk_lvlPL, stkidxPL, PL, PLstack );
 
       PG = ((PGFull/*>>4*/) / 240UL);
       PG0x = ((PG0__/*>>4*/) / 240UL);
       if ( PG < PG0x )             // check if negative value
         PG = PG0x;                //correct  it
       PG = PG - PG0x;
       PS = ( double )(xxxxPSFull/*/16ULL)*/) / (( double )/*COUNT_MEASURES*/xxxxPSFullmsrs);
       PS0x = ( double )(xxxxPS0/*/16ULL*/) / (( double )xxxxPS0msrs/*240*//*COUNT_MEASURES*/);
        //      struct _outbuf_descr *ob_ptr;
       if ( PS < PS0x )
         PS = PS0x;
  PSmomentary = (( double )(400UL / xcoeff)) * (( double )(PS - PS0x)); // get complex result
  if ( PSmomentary < 1.0 )
  {
    PSmomentary = 1.0;
  }
  push(stk_lvlPS, stkidxPS, PSmomentary, PSstack );
  if ( CORR_val == -3.14159265358979323 )
  {
    CORR_val = (PSlsb * ( double )MORlsb - PSmsb * ( double )MORmsb) / (( double )MORlsb - ( double )MORmsb);
  }
  if ( SIGMA == -3.14159265358979323 )
  {
    SIGMA = MORlsb * (PSlsb - CORR_val);
  }
      /**********************************************************************************/
   //MORmomentary = SIGMA / (((PSmomentary - CORR_val) < 1.0) ? (1) : (PSmomentary - CORR_val));
   MORmomentary_koeff = MORmomentary;
   MORmomentary=count_termo(MORmomentary);
   MORmomentary=SIGMA/(((PSmomentary-CORR_val) < 0.1)?(0.1):(PSmomentary-CORR_val));   //14_09_2020
/**********************************************************************************/
   if ((aging_LED == 1) && (flag_Kp == 1))
        {
            if(PL != 0) Kp = (double)PL/PLref;
            else Kp = 1.0;
            if (Kp >1.0) Kp =1.0;
            //MORmomentary_koeff = SIGMA / ((((PSmomentary / Kp) - CORR_val) < 1.0) ? (1) : ((PSmomentary / Kp) - CORR_val));
            MORmomentary_koeff = SIGMA / ((((PSmomentary / Kp) - CORR_val) < 0.1) ? (0.1) : ((PSmomentary / Kp) - CORR_val));   //14_09_2020
        }
        else
        {
           MORmomentary_koeff = MORmomentary; 
        }  

//      MORmomentary=SIGMA/(PSmomentary-CORR_val);
   if ( MORmomentary > 50000.0 )         ////////////!
   {
     MORmomentary = 50000.0;
   }
   push(stk_lvlMOR, stkidxMOR, MORmomentary, MORstack );
   uint32_t_to_segleds_with_dspoints( ( uint32_t )MORmomentary );
   MORstacked = pop(stk_lvlMOR, MORstack);
//  <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
   pogoda=weather(PS0x, MORstacked, termo_val);
   
       
//  <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

     

   }
           
      if (flag_out == 0 && flag_profile==0)
      {      //M0=1;M1=0;T485_EN=1;//tx
            HAL_GPIO_WritePin(M0_GPIO_Port, M0_Pin, GPIO_PIN_SET);
            /*M1=0;*/
            HAL_GPIO_WritePin(M1_GPIO_Port, M1_Pin, GPIO_PIN_RESET);
            /*T485_EN=1;//tx */
            HAL_GPIO_WritePin(RDE_GPIO_Port, RDE_Pin, GPIO_PIN_SET);
            putpkt((uint32_t)MORstacked, pogoda); // send prepared buffer
                                      //while (oidx<(sizeof(obuf)+1))
                                      //  continue ;
                                      //if (PINB_Bit7==1)
        {
          /*M0=0;*/
          HAL_GPIO_WritePin(M0_GPIO_Port, M0_Pin, GPIO_PIN_RESET);
          /*M1=1;*/
          HAL_GPIO_WritePin(M1_GPIO_Port, M1_Pin, GPIO_PIN_SET);
          /*T485_EN=0;//rx */
          HAL_GPIO_WritePin(RDE_GPIO_Port, RDE_Pin, GPIO_PIN_RESET);

          //while (UCSR1A_RXC1__!=0)
          //{
          //  UDR1;
          //}
          //      UCSR1B_RXEN__=1;
          //UCSR1B_RXCIE1__=1;
          {
            //uint32_t oldtime=get_time();
            //while ((get_time()-oldtime)<1000)
            {
              hstd=HAL_UART_Receive(&huart4, ibuf, 17, 1000);
              if (huart4.RxXferCount <= 4) //if (ibuf_rdy)
              //if(HAL_OK==hstd)
              {

                //checking crc
                uint16_t chk = 0;
                uint8_t chkhi=0;
                uint8_t chklo=0;
                int size_package=16;
                struct istruct__ *istr_ptr = (struct istruct__ *)ibuf;

 /*package processing from Peleng_Meteo*/
                if (ibuf[14]==0x0D)
                  size_package=14;
                for (int i = 1; i < size_package-2;i++)
                {
                  chk += ibuf[i];
                }
                chk = (chk & 0xff) + ((chk >> 8) & 0xff);
                chkhi = ((chk >> 4) & 0xf)+0x40;
                chklo = (chk & 0xf) + 0x40;
                if (ibuf[14]==0x0D)
                {
                  for(int i = 16; i >3;i--)
                  {
                    ibuf[i]=ibuf[i-2];
                  }
                  istr_ptr->modebt=0x32;
                }
/*
15-1=14 XX  Контрольная сумма    Старший разряд
16-1=15 XX  Контрольная сумма   Младший разряд
17-1=16 0D  Стоп    «Возврат каретки»
*/
                if ((ibuf[14]==chkhi && ibuf[15]==chklo) )
                {
                  switch (istr_ptr->modebt)
                  {
                  case 0x32://mode=calibration
                    {
                      uint32_t MORinput = 0ul;
                      uint16_t j, k;
                      MORinput = 0;
                      PLref=PLmomentary;
                      for (k = 1, j = 8; j > 3; k *= 10, j--)
                      {
                        MORinput += (uint32_t)(ibuf[j] - '0') * (uint32_t)k;
                      }
                      if (MORinput >= 5000ul)
                      {
                        MORmsb = MORinput;
                        PSmsb =  pop(stk_lvlPS, PSstack);
                      }
                      else
                      {
                        MORlsb = MORinput;
                        PSlsb =  pop(stk_lvlPS, PSstack);
                      }
                      CORR_val = (PSlsb * (double)MORlsb - PSmsb * (double)MORmsb) /
                          ((double)MORlsb - (double)MORmsb);
                      SIGMA = MORlsb * (PSlsb - CORR_val);

                      ibuf_rdy = false;
                      iidx = 0;
                    }
                    break;
                  case 0x33://mode=COMMAND
//                    else
                    {
                      uint32_t MORinput = 0ul;
                      uint16_t j, k;
                      for (k = 1, j = 13; j > 4; k *= 10, j--)
                      {
                        if (ibuf[j] >= '0')
                        {
                          MORinput += (uint32_t)(ibuf[j] - '0') * (uint32_t)k;
                        }
                      }
                      if (MORinput == 0x5a5a) flag_out = 1;
                      if (MORinput == 0x5b5b )
                      {
                        flag_profile = 1;
                         if ( huart4.Init.BaudRate != 57600 )
                         {
                           HAL_UART_DeInit( &huart4 );
                           huart4.Init.BaudRate = 57600;
                           HAL_UART_Init( &huart4 );
                         }
                      }

                      ibuf_rdy = false;
                      iidx = 0;
                    }
                    break;
                  case 0x34: //write parameter  wo ans
                    {
                      switch (istr_ptr->stsbt)
                      {
                      case 0x34: //status = write drizzlethreshold
                        {
                          drizzlethreshold = (uint16_t)get_double_from_pkt(&istr_ptr->date0bt);
                        }
                        break;
                      case 0x35: //status = write precipitationthreshold
                        {
                          precipitationthreshold = (uint16_t)get_double_from_pkt(&istr_ptr->date0bt);
                        }
                        break;
                      }
                    }
                    break;
                  case 0x35:  //mode 0x35  read parameter
                    {
                        //M0=1;M1=0;T485_EN=1;//tx
                        HAL_GPIO_WritePin(M0_GPIO_Port, M0_Pin, GPIO_PIN_SET);
                        /*M1=0;*/
                        HAL_GPIO_WritePin(M1_GPIO_Port, M1_Pin, GPIO_PIN_RESET);
                        /*T485_EN=1;//tx */
                        HAL_GPIO_WritePin(RDE_GPIO_Port, RDE_Pin, GPIO_PIN_SET);
                        HAL_Delay(25);
                      switch (istr_ptr->stsbt)
                      {
                      case 0x32://read SIGMA
                        putpkt(istr_ptr->stsbt, istr_ptr->modebt, (double)SIGMA);
                        break;
                      case 0x33:
                        putpkt(istr_ptr->stsbt, istr_ptr->modebt, (double)maxminamplitude);
                        break;
                      case 0x34:
                        putpkt(istr_ptr->stsbt, istr_ptr->modebt, (double)drizzlethreshold);
                        break;
                      case 0x35:
                        putpkt(istr_ptr->stsbt, istr_ptr->modebt, (double)precipitationthreshold);
                        break;
                      }
                    }
                    break;
                  case 0x36:     // no ans maxmin
                    e_maxminamplitude = maxminamplitude;
                    break;
                  }
                }
              }
            }
            //UCSR1B_RXCIE1__=0;
            //        UCSR1B_RXEN__=0;
            //M0=1;M1=0;T485_EN=1;//tx
            HAL_GPIO_WritePin(M0_GPIO_Port, M0_Pin, GPIO_PIN_SET);
            /*M1=0;*/
            HAL_GPIO_WritePin(M1_GPIO_Port, M1_Pin, GPIO_PIN_RESET);
            /*T485_EN=1;//tx */
            HAL_GPIO_WritePin(RDE_GPIO_Port, RDE_Pin, GPIO_PIN_SET);
          }
        }
      }
      else
      {
        if(flag_profile==0)
        {
          uint16_t xcoeff_ = xcoeff;
          pprs.PLFull = PLFull/240;
          pprs.PL0 = PL0__/240;
          pprs.PL = PL;
          pprs.PGFull = PGFull/240;
          pprs.PG0 = PG0__/240;
          pprs.PG = PG;
          pprs.MORmsb = MORmsb;
          pprs.PSmsb = PSmsb;
          pprs.MORlsb = MORlsb;
          pprs.PSlsb = PSlsb;
          pprs.CORR = CORR_val;
          pprs.SIGMA = SIGMA;
          pprs.PSfull_momentary = ((double)(400UL / xcoeff_)) * PS;
          pprs.PS0_momentary = ((double)(400UL / xcoeff_)) * PS0x;
          pprs.PSmomentary = PSmomentary;
          pprs.MORmomentary = MORmomentary;

          putpkt_debug(/*MORmsb,
                     PSmsb,
                     MORlsb,
                     PSlsb,
                     CORR_val,
                     SIGMA,
                     ((double)(400UL / xcoeff_)) * PS,
                     ((double)(400UL / xcoeff_)) * PS0x,
                     PSmomentary,
                     MORmomentary*/
                     &pprs
                    );
          if (true == getpkt())
          {
            struct istruct__ *istr_ptr = (struct istruct__ *)ibuf;
            if (istr_ptr->modebt==0x33)
            {
              flag_out = 0;
            }
          }
        }
      }
      dataready = false;
    }

//  if ( (termo_rdy()&0x80)!=0 )
//  {
//    temperature = get_termoval();
//  }
//
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_LSI
                              |RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
  RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }
  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
  {
    Error_Handler();
  }
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_UART4|RCC_PERIPHCLK_I2C1
                              |RCC_PERIPHCLK_I2C2|RCC_PERIPHCLK_TIM1;
  PeriphClkInit.Uart4ClockSelection = RCC_UART4CLKSOURCE_PCLK1;
  PeriphClkInit.I2c1ClockSelection = RCC_I2C1CLKSOURCE_HSI;
  PeriphClkInit.I2c2ClockSelection = RCC_I2C2CLKSOURCE_HSI;
  PeriphClkInit.Tim1ClockSelection = RCC_TIM1CLK_HCLK;
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
  {
    Error_Handler();
  }
}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */

  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     tex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
